{% extends "base.html" %}

{% block content %}
<div class="container mt-4">
    <h2 class="mb-4">15-7 Viterbi Algorithm (Graph Path Finding)</h2>
    
    <!-- Problem Description -->
    <div class="card mb-4">
        <div class="card-header bg-light">
            <i class="fas fa-book"></i> Problem Description (Original)
        </div>
        <div class="card-body">
            <p><strong>15-7 Viterbi algorithm</strong></p>
            <p>We can use dynamic programming on a directed graph $G = (V, E)$ for speech recognition. Each edge $(u, v) \in E$ is labeled with a sound $\sigma(u, v)$ from a finite set $\Sigma$ of sounds. The labeled graph is a formal model of a person speaking a restricted language. Each path in the graph starting from a distinguished vertex $v_0 \in V$ corresponds to a possible sequence of sounds produced by the model. We define the label of a directed path to be the concatenation of the labels of the edges on that path.</p>
            
            <p><strong>a.</strong> Describe an efficient algorithm that, given an edge-labeled graph $G$ with distinguished vertex $v_0$ and a sequence $s = \langle \sigma_1, \sigma_2, \dots, \sigma_k \rangle$ of sounds from $\Sigma$, returns a path in $G$ that begins at $v_0$ and has $s$ as its label, if any such path exists. Otherwise, the algorithm should return NO-SUCH-PATH. Analyze the running time of your algorithm.</p>
            
            <p><strong>b.</strong> Now, suppose that every edge $(u, v) \in E$ has an associated nonnegative probability $p(u, v)$ of traversing the edge $(u, v)$ from vertex $u$ and thus producing the corresponding sound. The sum of the probabilities of the edges leaving any vertex equals 1. The probability of a path is defined to be the product of the probabilities of its edges. We can view the probability of a path beginning at $v_0$ as the probability that a "random walk" beginning at $v_0$ will follow the specified path, where we randomly choose which edge to take leaving a vertex $u$ according to the probabilities of the available edges leaving $u$. Extend your answer to part (a) so that if a path is returned, it is a most probable path starting at $v_0$ and having label $s$. Analyze the running time of your algorithm.</p>
        </div>
    </div>

    <div class="row">
        <div class="col-md-12 mb-3">
            <button class="btn btn-primary me-2" id="startBtn">開始演示</button>
            <button class="btn btn-secondary me-2" id="prevBtn" disabled>上一步</button>
            <button class="btn btn-secondary me-2" id="nextBtn" disabled>下一步</button>
            <button class="btn btn-success me-2" id="autoBtn" disabled>自動播放</button>
            <button class="btn btn-danger" id="resetBtn">重置</button>
        </div>
    </div>

    <div class="row">
        <!-- Left: Graph Visualization -->
        <div class="col-md-7">
            <div class="card mb-4">
                <div class="card-header">圖形視覺化 (Graph)</div>
                <div class="card-body text-center" style="position: relative; height: 400px; background-color: #f8f9fa;">
                    <canvas id="graphCanvas" width="600" height="380"></canvas>
                </div>
            </div>
            
            <!-- DP Table -->
            <div class="card">
                <div class="card-header">DP 狀態表</div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table class="table table-bordered table-sm text-center" id="dpTable">
                            <!-- Generated by JS -->
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right: Explanation -->
        <div class="col-md-5">
            <div class="card mb-3">
                <div class="card-header bg-info text-white">
                    <i class="fas fa-info-circle"></i> 演算法說明
                </div>
                <div class="card-body">
                    <div class="alert alert-primary" role="alert" id="step-explanation">
                        點擊「開始演示」以執行 Viterbi 演算法。
                    </div>
                    
                    <div class="mt-3">
                        <h5>(a) 路徑存在性 (Reachability)</h5>
                        <p>
                            令 $reachable[i][v]$ 表示從 $v_0$ 出發，經過標記為 $\sigma_1 \dots \sigma_i$ 的路徑是否能到達 $v$。
                        </p>
                        <p>
                            $$reachable[i][v] = \bigvee_{(u,v) \in E, \sigma(u,v)=\sigma_i} reachable[i-1][u]$$
                        </p>
                        
                        <hr>
                        
                        <h5>(b) 最可能路徑 (Viterbi)</h5>
                        <p>
                            令 $P[i][v]$ 為到達 $v$ 的最大路徑機率。
                        </p>
                        <p>
                            $$P[i][v] = \max_{(u,v) \in E, \sigma(u,v)=\sigma_i} (P[i-1][u] \cdot p(u,v))$$
                        </p>
                    </div>
                    
                    <button class="btn btn-outline-secondary btn-sm mt-2" data-bs-toggle="modal" data-bs-target="#fullExplanationModal">
                        查看完整說明與虛擬碼
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Full Explanation Modal -->
<div class="modal fade" id="fullExplanationModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">15-7 Viterbi Algorithm - 完整說明</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <h4>(a) 解答：DP 判斷是否有對應路徑</h4>
                <p><strong>想法：</strong>把時間（聲音位置）當成一維，把圖的頂點當成另一維，做動態規劃。</p>
                <p>令 $reachable[i][v]$ 表示：從 $v_0$ 出發，走長度 $i$ 的路徑、標記是 $\sigma_1 \dots \sigma_i$ 時，是否能到達頂點 $v$。</p>
                
                <h5>虛擬碼 (Pseudocode)</h5>
                <pre class="bg-light p-3 border rounded">
// 初始
reachable[0][v0] = true
其他頂點為 false

// 轉移：對 i = 1..k
for i = 1 to k
    for all v in V: reachable[i][v] = false
    for each edge (u,v) in E
        if reachable[i-1][u] == true and σ(u,v) == σ_i
            reachable[i][v] = true
            predecessor[i][v] = u

// 結果
如果存在某個 v 使 reachable[k][v] == true
    沿著 predecessor[k][v] 逆推路徑
否則
    return NO-SUCH-PATH
                </pre>
                <p>時間複雜度：$\Theta(k|E|)$</p>

                <hr>

                <h4>(b) 解答：Viterbi – 最可能路徑</h4>
                <p>現在要最大化路徑機率。令 $P[i][v]$ = 從 $v_0$ 出發，標記為 $\sigma_1 \dots \sigma_i$ 且終點為 $v$ 的最大機率。</p>
                
                <h5>虛擬碼 (Pseudocode)</h5>
                <pre class="bg-light p-3 border rounded">
// 初始
P[0][v0] = 1
其他頂點 0

// 轉移（對 i=1..k）
for i = 1 to k
    for each v in V: P[i][v] = 0
    for each edge (u,v) in E
        if σ(u,v) == σ_i and P[i-1][u] > 0
            cand = P[i-1][u] * p(u,v)
            if cand > P[i][v]
                P[i][v] = cand
                pred[i][v] = u

// 結果
v* = argmax_v P[k][v]
若最大值為 0 則無路徑，否則逆推。
                </pre>
            </div>
        </div>
    </div>
</div>

<script src="{{ url_for('static', filename='js/viterbi.js') }}"></script>
{% endblock %}
