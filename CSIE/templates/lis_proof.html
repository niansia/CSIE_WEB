{% extends "base.html" %}

{% block title %}15.4-6 LIS O(n log n) Proof{% endblock %}

{% block content %}
<div class="container mt-5">
    <div class="row mb-4">
        <div class="col-12">
            <h1 class="text-center mb-4">15.4-6 Longest Increasing Subsequence O(n lg n)</h1>
            <div class="card">
                <div class="card-body">
                    <h5 class="card-title">題目敘述 (15.4-6)</h5>
                    <p class="card-text" style="text-align: justify;">
                        Give an $O(n \lg n)$-time algorithm to find the longest monotonically increasing subsequence of a sequence of $n$ numbers. (Hint: Observe that the last element of a candidate subsequence of length $i$ is at least as large as the last element of a candidate subsequence of length $i-1$. Maintain candidate subsequences by linking them through the input sequence.)
                    </p>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-md-12">
            <div class="card mb-4">
                <div class="card-header bg-light">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">演算法演示</h5>
                        <div class="btn-group">
                            <button id="prevBtn" class="btn btn-secondary" disabled>上一步</button>
                            <button id="playPauseBtn" class="btn btn-primary">播放</button>
                            <button id="nextBtn" class="btn btn-secondary">下一步</button>
                            <button id="resetBtn" class="btn btn-warning">重新生成數據</button>
                        </div>
                    </div>
                </div>
                <div class="card-body text-center">
                    <div id="step-description" class="alert alert-info mb-3" style="min-height: 80px; font-size: 1.1em; white-space: pre-wrap;">
                        準備中...
                    </div>
                    <div class="canvas-container" style="position: relative; width: 100%; height: 400px; border: 1px solid #ddd; background-color: #fafafa;">
                        <canvas id="proofCanvas" width="800" height="400"></canvas>
                    </div>
                    <div class="mt-3">
                        <label for="speedRange" class="form-label">演示速度: <span id="speedValue">3</span></label>
                        <input type="range" class="form-range" id="speedRange" min="1" max="5" value="3">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    演算法邏輯
                </div>
                <div class="card-body">
                    <p><strong>關鍵想法：</strong></p>
                    <ul>
                        <li>維護一個陣列 <code>tails</code>，其中 <code>tails[i]</code> 儲存長度為 $i+1$ 的遞增子序列的<strong>最小結尾元素</strong>的索引。</li>
                        <li>對於每個新元素 $a[k]$，我們在 <code>tails</code> 中進行二分搜尋 (Binary Search)，找到第一個大於等於 $a[k]$ 的元素位置。</li>
                        <li>如果找到，則更新該位置的值為 $a[k]$ (因為 $a[k]$ 更小，更有利於後續延伸)。</li>
                        <li>如果沒找到 (所有 <code>tails</code> 元素都小於 $a[k]$)，則將 $a[k]$ 接在最後，延長 LIS。</li>
                        <li>同時維護 <code>pred</code> 陣列記錄前驅節點，以便最後回朔重建序列。</li>
                    </ul>
                    <p><strong>時間複雜度：</strong> 每個元素做一次二分搜尋 $O(\lg n)$，總共 $n$ 個元素，故為 $O(n \lg n)$。</p>
                    <hr>
                    <p><strong>偽程式碼 (Pseudocode)：</strong></p>
                    <pre style="background-color: #f8f9fa; padding: 15px; border-radius: 5px; font-family: monospace;">
LIS-NLOGN(a[1..n])
1  建立陣列 tail[1..n], pred[1..n]
2  L = 0
3  for k = 1..n
4      // 在 1..L 中找最大 ℓ 使 a[tail[ℓ]] < a[k]
5      ℓ = binary_search_max_less(a, tail, L, a[k])
6      newLen = ℓ + 1
7      pred[k] = (newLen == 1) ? NIL : tail[newLen - 1]
8      tail[newLen] = k
9      if newLen > L: L = newLen
10 // 回朔得到 LIS
11 idx = tail[L]
12 建立陣列 seq[1..L]
13 for i = L downto 1
14     seq[i] = a[idx]
15     idx = pred[idx]
16 return seq</pre>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
  window.MathJax = {
    options: {
      enableMenu: false
    },
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="{{ url_for('static', filename='js/lis_proof.js') }}"></script>
{% endblock %}
