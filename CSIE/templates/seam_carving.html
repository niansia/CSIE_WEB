{% extends "base.html" %}

{% block title %}15-8 Image Compression by Seam Carving{% endblock %}

{% block content %}
<div class="container">
    <h1 class="mb-4">15-8 Image Compression by Seam Carving</h1>
    
    <div class="alert alert-info">
        <h4>Problem Description</h4>
        <p>
            We are given a color picture consisting of an $m \times n$ array $A[1..m, 1..n]$ of pixels, where each pixel specifies a triple of red, green, and blue (RGB) intensities. Suppose that we wish to compress this picture slightly. Specifically, we wish to remove one pixel from each of the $m$ rows, so that the whole picture becomes one pixel narrower. To avoid disturbing visual effects, however, we require that the pixels removed in two adjacent rows be in the same or adjacent columns; the pixels removed form a "seam" from the top row to the bottom row where successive pixels in the seam are adjacent vertically or diagonally.
        </p>
        <ol type="a">
            <li>Show that the number of such possible seams grows at least exponentially in $m$, assuming that $n > 1$.</li>
            <li>Suppose now that along with each pixel $A[i, j]$, we have calculated a real-valued disruption measure $d[i, j]$, indicating how disruptive it would be to remove pixel $A[i, j]$. Intuitively, the lower a pixel's disruption measure, the more similar the pixel is to its neighbors. Suppose further that we define the disruption measure of a seam to be the sum of the disruption measures of its pixels.<br>
            Give an algorithm to find a seam with the lowest disruption measure. How efficient is your algorithm?</li>
        </ol>
    </div>

    <div class="row mb-4">
        <div class="col-md-12">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    (a) 解答：至少指數多條 seam
                </div>
                <div class="card-body">
                    <p>要證明「至少指數多」，只要挑一個寬度 2 的子網格就夠。</p>
                    <p>想像只看最左兩欄（或任意相鄰兩欄），忽略其他欄位。</p>
                    <p>在這個 $m \times 2$ 的子網格中，每一列的 seam 像素一定在第 1 或第 2 欄，且上下相鄰列的欄位差最多 1。這等價於從上到下走一條路徑，每一步可以：</p>
                    <ul>
                        <li>從左欄走到左欄（直走）</li>
                        <li>從左欄走到右欄（斜）</li>
                        <li>從右欄走到右欄（直）</li>
                        <li>從右欄走到左欄（斜）</li>
                    </ul>
                    <p>這樣的路徑數，其實跟長度為 $m$ 的「走右 / 走左」路徑一樣，是 Fibonacci 型成長，數量約為 $\Theta(\phi^m)$ ($\phi$ 為黃金比例)，因此是指數級 $\Omega(c^m)$；再加上還可以利用其他欄位，只會更多。</p>
                    <p><strong>所以 seam 的數量至少以 $m$ 為指數成長。</strong></p>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-md-7">
            <div class="card mb-4">
                <div class="card-header">
                    Seam Carving 視覺化 (Part B)
                </div>
                <div class="card-body">
                    <div class="mb-3">
                        <button id="startBtn" class="btn btn-primary">開始演示</button>
                        <button id="prevBtn" class="btn btn-secondary" disabled>上一步</button>
                        <button id="nextBtn" class="btn btn-secondary" disabled>下一步</button>
                        <button id="autoBtn" class="btn btn-success" disabled>自動播放</button>
                        <button id="resetBtn" class="btn btn-danger">重置</button>
                    </div>
                    
                    <div id="grid-container" class="text-center position-relative">
                        <!-- Grid will be generated here -->
                        <table class="table table-bordered table-sm" id="seamTable" style="table-layout: fixed;">
                            <!-- Content generated by JS -->
                        </table>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-md-5">
            <div class="card">
                <div class="card-header bg-info text-white">
                    (b) 演算法說明與狀態
                </div>
                <div class="card-body">
                    <div class="alert alert-secondary" id="step-explanation" style="min-height: 100px;">
                        點擊「開始演示」以執行 Seam Carving 演算法。
                    </div>
                    
                    <hr>
                    <h5>(b) 解答：DP 找最小破壞度 seam</h5>
                    <p><strong>定義</strong><br>
                    $C[i, j] =$ 從最上列到達像素 $(i, j)$ 的所有 seam 中，最小破壞度</p>
                    
                    <p><strong>邊界</strong><br>
                    第一列只能直接選該像素：<br>
                    $C[1, j] = d[1, j]$</p>
                    
                    <p><strong>轉移</strong><br>
                    對第 $i$ 列 ($i>1$) 的像素 $(i,j)$，上一步可以從 $(i-1,j-1)$、$(i-1,j)$、$(i-1,j+1)$ 來（若在邊界就略掉不合法欄位）：<br>
                    $C[i, j] = d[i, j] + \min (C[i - 1, j - 1], C[i - 1, j], C[i - 1, j + 1])$</p>
                    
                    <p><strong>最後答案是</strong><br>
                    $\min_j C[m, j]$</p>
                    
                    <p>要重建 seam，只要從最後一列的最小欄位往上，每次往使 $C[i, j]$ 達到式子的那個上一列欄位走。</p>
                    
                    <p><strong>複雜度</strong><br>
                    時間：每個格子計算一次，最多看 3 個鄰居 $\to \Theta(mn)$。<br>
                    空間：表格 $\Theta(mn)$，若只存兩列可壓到 $\Theta(n)$。</p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="{{ url_for('static', filename='js/seam_carving.js') }}"></script>
{% endblock %}
